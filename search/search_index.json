{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About ACE is a model-based configuration authoring and validation environment. It aims at bringing determinism to tool configuration by externalizing the configuration definition into a separate model file. The model file is used to check the validity of a configuration instance, browse available options, and generate the necessary source code to access the options values. Installation Prepare Grab the source code . ACE has several dependencies, listed below. Dependencies with checkmarks can be installed using Conan : lemon ragel TCLAP RE2 GTest if testing is enabled hjson for HJSON support jansson for JSON support Python 2.x for Python support Lua 5.2.4 for Lua support yaml-cpp for YAML support Building without Conan ACE uses CMake as its build system. To build the project, simply run the following commands: cd ace mkdir build cd build cmake .. make make install Building with Conan To build the project using Conan , run the following commands: cd ace mkdir build cd build conan install .. cmake .. make make install Tweaking the build process The cmake command accepts the following variables (default is shown bold ): ACE_PLUGIN_HJSON : enables the HJSON file plugin. Accepts ON or OFF . ACE_PLUGIN_JSON : enables the JSON file plugin. Accepts ON or OFF . ACE_PLUGIN_LUA : enables the LUA file plugin. Accepts ON or OFF . ACE_PLUGIN_PYTHON : enables the PYTHON file plugin. Accepts ON or OFF . ACE_PLUGIN_TOML : enables the TOML file plugin. Accepts ON or OFF . ACE_PLUGIN_YAML : enables the YAML file plugin. Accepts ON or OFF . ACE_PLUGIN_TESTS : builds the test suite. Accepts ON or OFF . The standard cmake variable CMAKE_INSTALL_PREFIX shall be used to alter the installation prefix: cd ace mkdir build cd build cmake -DCMAKE_INSTALL_PREFIX=/opt .. make make install Getting started Model definition The first step is to define a model for our example configuration, saved into a Model.json file: { \"header\": { \"author\": { \"name\": \"John Doe\", \"email\": \"jdoe@acme.com\" }, \"version\": \"1.0\", \"namespace\": [ \"my\", \"ns\" ], \"doc\": \"ACME configuration model\" }, \"body\": { \"intItem\": { \"kind\": \"integer\", \"arity\": \"?\", \"doc\": \"an integer option\" }, \"stringItem\": { \"kind\": \"string\", \"arity\": \"1\", \"doc\": \"a string option\" }, \"floatItem\": { \"kind\": \"float\", \"arity\": \"*\", \"doc\": \"a float option\" }, \"booleanItem\": { \"kind\": \"boolean\", \"arity\": \"+\", \"doc\": \"a boolean option\" } } } This model defines 4 configuration items: a integer item intItem , a string item stringItem , a float item floatItem , and a boolean item booleanItem . Beside its kind, each item declares its arity and documnetation. Model transpilation The second step is to transpile that model into a set of helper classes that can be used in a C++ application. ace-compile Model.json The ace-compile command produces 3 files: an interface header file IModel.ac.h , an implementation header file Model.ac.h , and an implementation source file Model.ac.cpp . Code integration The third step is to make use of the generated files in our example application. ACE provides a set of helper functions that simplify that task: #include <Model.ac.h> #include <ace/engine/Master.h> #include <ace/model/Helper.h> #include <tclap/CmdLine.h> #include <string> using namespace ace::model::Helper; int main(int argc, char *argv[]) { // Define CLI arguments TCLAP::CmdLine cmd(\"ACME Tool\", ' ', \"0.1\"); TCLAP::ValueArg<std::string> cfgPath(\"c\", \"config\", \"Configuration file\", true, \"\", \"string\"); cmd.add(cfgPath); cmd.parse(argc, argv); // Instantiate the configuration // auto cfg = parseFile<my::ns::Model>(cfgPath.getValue(), false, argc, argv); if (cfg == nullptr) return -1; // Use it ! // auto const & acme = *cfg; if (acme.has_intItem()) { std::cout << \"int = \" << acme.intItem() << std::endl; } for (auto const & f : acme.floatItem()) { std::cout << \"float = \" << f << std::endl; } for (auto const & b : acme.booleanItem()) { std::cout << \"bool = \" << b << std::endl; } std::cout << \"str = \" << acme.stringItem() << std::endl; return 0; } Please note that the code above makes use of TCLAP to parse the command line arguments. This is an arbitrary choice and you are free to use whichever CLI option parser you wish. Testing Finally, we are ready to test our application. First, let's compile it using the following Makefile: CFLAGS = -g3 -x c++ -std=c++11 -I . -I $(ACE_INCLUDE_PATH) LFLAGS = -L $(ACE_LIB_PATH) -rpath $(ACE_LIB_PATH) all: clean ace bin ace: ace-compile -I . Model.json bin: c++ $(CFLAGS) -c main.cpp c++ $(CFLAGS) -c Model.ac.cpp c++ $(LFLAGS) -o main main.o Model.ac.o -lace clean: rm -f *.ac.* *.o main Next, let's define a configuration file, in TOML, called config.toml : intItem = 17 stringItem = \"Hello!\" floatItem = 3.14 booleanItem = [ true, false, false ] Finally, let's run our application: ./main -c config.toml The expected output it: int = 17 float = 3.14 bool = 1 bool = 0 bool = 0 str = Hello! Since ACE also supports JSON, Python and Lua, we can also use these configuration files: { \"intItem\" : 17, \"stringItem\" : \"Hello!\", \"floatItem\" : 3.14, \"booleanItem\" : [ true, false, false ], \"selectItem\" : \"hello\", \"hello\" : \"world\" } a Python configuration file: config = { 'intItem' : 17, 'stringItem' : 'Hello!', 'floatItem' : 3.14, 'booleanItem' : [ True, False, False ], 'selectItem': 'hello', 'hello': 'world' } or a Lua configuration file: config = { intItem = 17, stringItem = 'Hello!', floatItem = 3.14, booleanItem = { true, false, false } selectItem = 'hello', hello = 'world' }","title":"Home"},{"location":"#about","text":"ACE is a model-based configuration authoring and validation environment. It aims at bringing determinism to tool configuration by externalizing the configuration definition into a separate model file. The model file is used to check the validity of a configuration instance, browse available options, and generate the necessary source code to access the options values.","title":"About"},{"location":"#installation","text":"","title":"Installation"},{"location":"#prepare","text":"Grab the source code . ACE has several dependencies, listed below. Dependencies with checkmarks can be installed using Conan : lemon ragel TCLAP RE2 GTest if testing is enabled hjson for HJSON support jansson for JSON support Python 2.x for Python support Lua 5.2.4 for Lua support yaml-cpp for YAML support","title":"Prepare"},{"location":"#building-without-conan","text":"ACE uses CMake as its build system. To build the project, simply run the following commands: cd ace mkdir build cd build cmake .. make make install","title":"Building without Conan"},{"location":"#building-with-conan","text":"To build the project using Conan , run the following commands: cd ace mkdir build cd build conan install .. cmake .. make make install","title":"Building with Conan"},{"location":"#tweaking-the-build-process","text":"The cmake command accepts the following variables (default is shown bold ): ACE_PLUGIN_HJSON : enables the HJSON file plugin. Accepts ON or OFF . ACE_PLUGIN_JSON : enables the JSON file plugin. Accepts ON or OFF . ACE_PLUGIN_LUA : enables the LUA file plugin. Accepts ON or OFF . ACE_PLUGIN_PYTHON : enables the PYTHON file plugin. Accepts ON or OFF . ACE_PLUGIN_TOML : enables the TOML file plugin. Accepts ON or OFF . ACE_PLUGIN_YAML : enables the YAML file plugin. Accepts ON or OFF . ACE_PLUGIN_TESTS : builds the test suite. Accepts ON or OFF . The standard cmake variable CMAKE_INSTALL_PREFIX shall be used to alter the installation prefix: cd ace mkdir build cd build cmake -DCMAKE_INSTALL_PREFIX=/opt .. make make install","title":"Tweaking the build process"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#model-definition","text":"The first step is to define a model for our example configuration, saved into a Model.json file: { \"header\": { \"author\": { \"name\": \"John Doe\", \"email\": \"jdoe@acme.com\" }, \"version\": \"1.0\", \"namespace\": [ \"my\", \"ns\" ], \"doc\": \"ACME configuration model\" }, \"body\": { \"intItem\": { \"kind\": \"integer\", \"arity\": \"?\", \"doc\": \"an integer option\" }, \"stringItem\": { \"kind\": \"string\", \"arity\": \"1\", \"doc\": \"a string option\" }, \"floatItem\": { \"kind\": \"float\", \"arity\": \"*\", \"doc\": \"a float option\" }, \"booleanItem\": { \"kind\": \"boolean\", \"arity\": \"+\", \"doc\": \"a boolean option\" } } } This model defines 4 configuration items: a integer item intItem , a string item stringItem , a float item floatItem , and a boolean item booleanItem . Beside its kind, each item declares its arity and documnetation.","title":"Model definition"},{"location":"#model-transpilation","text":"The second step is to transpile that model into a set of helper classes that can be used in a C++ application. ace-compile Model.json The ace-compile command produces 3 files: an interface header file IModel.ac.h , an implementation header file Model.ac.h , and an implementation source file Model.ac.cpp .","title":"Model transpilation"},{"location":"#code-integration","text":"The third step is to make use of the generated files in our example application. ACE provides a set of helper functions that simplify that task: #include <Model.ac.h> #include <ace/engine/Master.h> #include <ace/model/Helper.h> #include <tclap/CmdLine.h> #include <string> using namespace ace::model::Helper; int main(int argc, char *argv[]) { // Define CLI arguments TCLAP::CmdLine cmd(\"ACME Tool\", ' ', \"0.1\"); TCLAP::ValueArg<std::string> cfgPath(\"c\", \"config\", \"Configuration file\", true, \"\", \"string\"); cmd.add(cfgPath); cmd.parse(argc, argv); // Instantiate the configuration // auto cfg = parseFile<my::ns::Model>(cfgPath.getValue(), false, argc, argv); if (cfg == nullptr) return -1; // Use it ! // auto const & acme = *cfg; if (acme.has_intItem()) { std::cout << \"int = \" << acme.intItem() << std::endl; } for (auto const & f : acme.floatItem()) { std::cout << \"float = \" << f << std::endl; } for (auto const & b : acme.booleanItem()) { std::cout << \"bool = \" << b << std::endl; } std::cout << \"str = \" << acme.stringItem() << std::endl; return 0; } Please note that the code above makes use of TCLAP to parse the command line arguments. This is an arbitrary choice and you are free to use whichever CLI option parser you wish.","title":"Code integration"},{"location":"#testing","text":"Finally, we are ready to test our application. First, let's compile it using the following Makefile: CFLAGS = -g3 -x c++ -std=c++11 -I . -I $(ACE_INCLUDE_PATH) LFLAGS = -L $(ACE_LIB_PATH) -rpath $(ACE_LIB_PATH) all: clean ace bin ace: ace-compile -I . Model.json bin: c++ $(CFLAGS) -c main.cpp c++ $(CFLAGS) -c Model.ac.cpp c++ $(LFLAGS) -o main main.o Model.ac.o -lace clean: rm -f *.ac.* *.o main Next, let's define a configuration file, in TOML, called config.toml : intItem = 17 stringItem = \"Hello!\" floatItem = 3.14 booleanItem = [ true, false, false ] Finally, let's run our application: ./main -c config.toml The expected output it: int = 17 float = 3.14 bool = 1 bool = 0 bool = 0 str = Hello! Since ACE also supports JSON, Python and Lua, we can also use these configuration files: { \"intItem\" : 17, \"stringItem\" : \"Hello!\", \"floatItem\" : 3.14, \"booleanItem\" : [ true, false, false ], \"selectItem\" : \"hello\", \"hello\" : \"world\" } a Python configuration file: config = { 'intItem' : 17, 'stringItem' : 'Hello!', 'floatItem' : 3.14, 'booleanItem' : [ True, False, False ], 'selectItem': 'hello', 'hello': 'world' } or a Lua configuration file: config = { intItem = 17, stringItem = 'Hello!', floatItem = 3.14, booleanItem = { true, false, false } selectItem = 'hello', hello = 'world' }","title":"Testing"},{"location":"deps/","text":"Dependencies Option value definition may have one or more dependencies on other option value definitions within the same model or across included models. The supported types of dependencies are presented below. Dependent types are addressed using a local JSONPath path. Requirement dependency When options are mentioned in this type of dependency, their arity is promoted to required . \"deps\": [ { \"require\": [ \"@.A\", ... ] } ] Disable dependency When options are mentioned in this type of dependency, their use is disabled. \"deps\": [ { \"disable\": [ \"@.A\", ... ] } ] Value-guarded dependency Value-guarded dependencies are activated only when the option has one of the value specified in the when list. \"deps\": [ { \"when\": [ v0, v1 ], \"require\": [ \"@.A\", ... ] } ] \"deps\": [ { \"when\": [ v0, v1 ], \"disable\": [ \"@.A\", ... ] } ] Constraint-guarded dependency Constraint-guarded dependencies enforce the final value of the dependent type. \"deps\": [ { \"require\": [ \"@.A\", ... ], \"either\": [ V1, V2 ] } ] \"deps\": [ { \"require\": [ \"@.A\", ... ], \"range\": \"[ V1, V2 ]\" } ] Mixing dependencies \"deps\": [ { \"require\": [ \"@.A\", ... ] }, { \"when\": [ V ], \"require\": [ \"@.A\", ... ] } ]","title":"Dependencies"},{"location":"deps/#dependencies","text":"Option value definition may have one or more dependencies on other option value definitions within the same model or across included models. The supported types of dependencies are presented below. Dependent types are addressed using a local JSONPath path.","title":"Dependencies"},{"location":"deps/#requirement-dependency","text":"When options are mentioned in this type of dependency, their arity is promoted to required . \"deps\": [ { \"require\": [ \"@.A\", ... ] } ]","title":"Requirement dependency"},{"location":"deps/#disable-dependency","text":"When options are mentioned in this type of dependency, their use is disabled. \"deps\": [ { \"disable\": [ \"@.A\", ... ] } ]","title":"Disable dependency"},{"location":"deps/#value-guarded-dependency","text":"Value-guarded dependencies are activated only when the option has one of the value specified in the when list. \"deps\": [ { \"when\": [ v0, v1 ], \"require\": [ \"@.A\", ... ] } ] \"deps\": [ { \"when\": [ v0, v1 ], \"disable\": [ \"@.A\", ... ] } ]","title":"Value-guarded dependency"},{"location":"deps/#constraint-guarded-dependency","text":"Constraint-guarded dependencies enforce the final value of the dependent type. \"deps\": [ { \"require\": [ \"@.A\", ... ], \"either\": [ V1, V2 ] } ] \"deps\": [ { \"require\": [ \"@.A\", ... ], \"range\": \"[ V1, V2 ]\" } ]","title":"Constraint-guarded dependency"},{"location":"deps/#mixing-dependencies","text":"\"deps\": [ { \"require\": [ \"@.A\", ... ] }, { \"when\": [ V ], \"require\": [ \"@.A\", ... ] } ]","title":"Mixing dependencies"},{"location":"gen/","text":"C++ code generation ACE provides a Model-to-C++ compiler, called ace-compile , to enable tools to interact with configuration files. It also provides helper tools to instantiate the generated class based on configuration instances. If a configuration parsing class has been successfully instantiated, the tool developer has the guarantee that all accessed configuration option values are valid according to the defined model. File organization ace-compile generates three types of files: model class interfaces <ModelName>Instance.ac.h ; model class declarations <ModelName>.ac.h ; and model class definitions <ModelName>.ac.cpp . Model class interfaces define pure virtual interfaces that contain the accessor prototypes of a given model. Only interfaces are used within the definition of class type accessor prototypes. Checkers and getters For each option, the compiler generates two accessors: a checker: bool has_<OptionName>() const if the arity of the option is either ? or * a getter: OptionType <OptionName>() const The value of OptionType depends on the arity and the type of the option: ? or 1 : OptionType is either BaseType or BaseType const & * or + : OptionType is std:vector<BaseType> const or std::vector<BaseType::Ref> const & The value of BaseType depends on the kind of type involved. It may be either bool , int , float , std::string , or <ModelName>Interface . BaseType const & is used for std::string and <ModelOption>Interface types. std::vector<BaseType::Ref> const & is used for <ModelOption>Interface . Handling inheritance The inclusion of external models is handled using multiple inheritance of pure virtual interfaces. The final implementation of the derived models instantiates itself all the configuration values. As a consequence, the declaration and definition files of models that only serve as base model in a model definition are not generated. When to included models define the same class option, the option is merged in the final model if and only if either the class models are identical or if one is a direct descendent of the other. In the later case, the compiler leverages C++ co-variant return types to implement the option accessors. The case of the Plugin type The code generation of the plugin kind of type is handle a bit differently that the other types. The plugin C++ type generated is a map from std::string to MODEL::Ref objects, containing the instantiated plugins. MODEL::Ref is a reference to the instantiated object casted into its base type. It's up to the user to up-cast that reference to the expected type. Example: \"options\": { \"kind\": \"plugin\", \"arity\": \"1\", \"model\": \"Base.json\" } The generated accessor: std::map<std::string, Base::Ref> const & options() const; For two triggered models ModelA and ModelB, the generic way to access the components is: IModelA const & modelA = std::static_pointer_cast<IModelA const &>(options().at(\"a\")); IModelB const & modelB = std::static_pointer_cast<IModelB const &>(options().at(\"b\")); To avoid verbose casting, a helper templated function is also generated to access generic components. The helper's name is the name of the options suffixed with _at : IModelA const & modelA = options_at<IModelA>(\"a\"); IModelB const & modelB = options_at<IModelB>(\"b\");","title":"Code generation"},{"location":"gen/#c-code-generation","text":"ACE provides a Model-to-C++ compiler, called ace-compile , to enable tools to interact with configuration files. It also provides helper tools to instantiate the generated class based on configuration instances. If a configuration parsing class has been successfully instantiated, the tool developer has the guarantee that all accessed configuration option values are valid according to the defined model.","title":"C++ code generation"},{"location":"gen/#file-organization","text":"ace-compile generates three types of files: model class interfaces <ModelName>Instance.ac.h ; model class declarations <ModelName>.ac.h ; and model class definitions <ModelName>.ac.cpp . Model class interfaces define pure virtual interfaces that contain the accessor prototypes of a given model. Only interfaces are used within the definition of class type accessor prototypes.","title":"File organization"},{"location":"gen/#checkers-and-getters","text":"For each option, the compiler generates two accessors: a checker: bool has_<OptionName>() const if the arity of the option is either ? or * a getter: OptionType <OptionName>() const The value of OptionType depends on the arity and the type of the option: ? or 1 : OptionType is either BaseType or BaseType const & * or + : OptionType is std:vector<BaseType> const or std::vector<BaseType::Ref> const & The value of BaseType depends on the kind of type involved. It may be either bool , int , float , std::string , or <ModelName>Interface . BaseType const & is used for std::string and <ModelOption>Interface types. std::vector<BaseType::Ref> const & is used for <ModelOption>Interface .","title":"Checkers and getters"},{"location":"gen/#handling-inheritance","text":"The inclusion of external models is handled using multiple inheritance of pure virtual interfaces. The final implementation of the derived models instantiates itself all the configuration values. As a consequence, the declaration and definition files of models that only serve as base model in a model definition are not generated. When to included models define the same class option, the option is merged in the final model if and only if either the class models are identical or if one is a direct descendent of the other. In the later case, the compiler leverages C++ co-variant return types to implement the option accessors.","title":"Handling inheritance"},{"location":"gen/#the-case-of-the-plugin-type","text":"The code generation of the plugin kind of type is handle a bit differently that the other types. The plugin C++ type generated is a map from std::string to MODEL::Ref objects, containing the instantiated plugins. MODEL::Ref is a reference to the instantiated object casted into its base type. It's up to the user to up-cast that reference to the expected type. Example: \"options\": { \"kind\": \"plugin\", \"arity\": \"1\", \"model\": \"Base.json\" } The generated accessor: std::map<std::string, Base::Ref> const & options() const; For two triggered models ModelA and ModelB, the generic way to access the components is: IModelA const & modelA = std::static_pointer_cast<IModelA const &>(options().at(\"a\")); IModelB const & modelB = std::static_pointer_cast<IModelB const &>(options().at(\"b\")); To avoid verbose casting, a helper templated function is also generated to access generic components. The helper's name is the name of the options suffixed with _at : IModelA const & modelA = options_at<IModelA>(\"a\"); IModelB const & modelB = options_at<IModelB>(\"b\");","title":"The case of the Plugin type"},{"location":"misc/","text":"Miscellaneous Alterations It is possible to use the command line arguments to alter the configuration. To use this feature, simple use the parseFile or parseString helper API, passing as a third argument a vector of string with the following format: X.Y.Z=VALUE . Example #include <Model.ac.h> #include <ace/engine/Master.h> #include <ace/model/Helper.h> #include <tclap/CmdLine.h> #include <string> using namespace ace::model::Helper; int main(int argc, char *argv[]) { // Define CLI arguments TCLAP::CmdLine cmd(\"ACME Tool\", ' ', \"0.1\"); TCLAP::ValueArg<std::string> cfgPath(\"c\", \"config\", \"Configuration file\", true, \"\", \"string\", cmd); TCLAP::MultiArg<std::string> defPath(\"D\", \"define\", \"A=B statements\", false, \"string\", cmd); cmd.parse(argc, argv); // Instantiate the configuration // auto cfg = parseFile<my::ns::Model>(cfgPath.getValue(), defPath.getValue(), false, argc, argv); if (cfg == nullptr) return -1; // Use it ! // auto const & acme = *cfg; if (acme.has_intItem()) { std::cout << \"int = \" << acme.intItem() << std::endl; } for (auto const & f : acme.floatItem()) { std::cout << \"float = \" << f << std::endl; } for (auto const & b : acme.booleanItem()) { std::cout << \"bool = \" << b << std::endl; } std::cout << \"str = \" << acme.stringItem() << std::endl; return 0; } Usage ./acme -c config_file.ini -D stringItem= -D stringItem=\"hello, world\" Syntax The parseFile or parseString helper expect a vector of strings with the following format: X.Y.Z=VALUE . X.Y.Z represents a path in the configuration tree. VALUE is the value that needs to be assigned to that path. The format used for the value is the same as the one use in the INI format. Altering the tree works as follows: Specifying an empty value for a path erase that value in the existing tree: -D X.Y.Z= Specifying one value for a path sets that value in the existing tree: -D X.Y.Z=VALUE Setting multiple values for a path appends these values to that path: -D X.Y.Z=VALUE1 -D X.Y.Z=VALUE2 -D X.Y.Z=VALUE3","title":"Miscellaneous"},{"location":"misc/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"misc/#alterations","text":"It is possible to use the command line arguments to alter the configuration. To use this feature, simple use the parseFile or parseString helper API, passing as a third argument a vector of string with the following format: X.Y.Z=VALUE .","title":"Alterations"},{"location":"misc/#example","text":"#include <Model.ac.h> #include <ace/engine/Master.h> #include <ace/model/Helper.h> #include <tclap/CmdLine.h> #include <string> using namespace ace::model::Helper; int main(int argc, char *argv[]) { // Define CLI arguments TCLAP::CmdLine cmd(\"ACME Tool\", ' ', \"0.1\"); TCLAP::ValueArg<std::string> cfgPath(\"c\", \"config\", \"Configuration file\", true, \"\", \"string\", cmd); TCLAP::MultiArg<std::string> defPath(\"D\", \"define\", \"A=B statements\", false, \"string\", cmd); cmd.parse(argc, argv); // Instantiate the configuration // auto cfg = parseFile<my::ns::Model>(cfgPath.getValue(), defPath.getValue(), false, argc, argv); if (cfg == nullptr) return -1; // Use it ! // auto const & acme = *cfg; if (acme.has_intItem()) { std::cout << \"int = \" << acme.intItem() << std::endl; } for (auto const & f : acme.floatItem()) { std::cout << \"float = \" << f << std::endl; } for (auto const & b : acme.booleanItem()) { std::cout << \"bool = \" << b << std::endl; } std::cout << \"str = \" << acme.stringItem() << std::endl; return 0; }","title":"Example"},{"location":"misc/#usage","text":"./acme -c config_file.ini -D stringItem= -D stringItem=\"hello, world\"","title":"Usage"},{"location":"misc/#syntax","text":"The parseFile or parseString helper expect a vector of strings with the following format: X.Y.Z=VALUE . X.Y.Z represents a path in the configuration tree. VALUE is the value that needs to be assigned to that path. The format used for the value is the same as the one use in the INI format. Altering the tree works as follows: Specifying an empty value for a path erase that value in the existing tree: -D X.Y.Z= Specifying one value for a path sets that value in the existing tree: -D X.Y.Z=VALUE Setting multiple values for a path appends these values to that path: -D X.Y.Z=VALUE1 -D X.Y.Z=VALUE2 -D X.Y.Z=VALUE3","title":"Syntax"},{"location":"models/","text":"Models Top-level structure Models are JSON objects that contain three entries: header , body and templates . The header entry contains information about the model, such as its author's name and e-mail, the its version string, and a line of documentation explaining the model's purpose. The body entry contains the definitions of the options expected by the model. The templates entry contains type definitions that can be injected into the model based on instance values. This injection is supported for options of type select . \"header\": { \"package\": [ \"my\", \"package\" ], \"author\": { \"name\": \"John Doe\", \"email\": \"jdoe@acme.com\" }, \"version\": \"1.0\", \"namespace\": [ \"my\", \"ns\" ], \"doc\": \"ACME configuration model\" } The package and namespace entries are related to C++ code generation. The package entry defines the compilation unit path of the configuration model. The compilation subsystem must provide an include path the can resolve the package path. The namespace entry defines the namespace to use for the generated classes. Inheritance A model can extend external pre-existing models. When extending models, the options defined in these models are imported and merged in the newly defined models. Extended models can in turns extend models themselves. To extends from existing models, a model need to declare path and name of extended models in its headers using the include clause as follows: \"header\": { \"name\": \"ACME_EX\", \"author\": { \"name\": \"John Doe\", \"email\": \"jdoe@acme.com\" }, \"version\": \"1.0\", \"include\": [ \"a_path/a_model.json\", ... ], \"doc\": \"ACME_EX configuration model\" } Multiple extended models may be defining options that bear the same name. In that case, ACE checks if the option types are compatible by kind, arity, and dependencies. If the types are compatible, the options are merged into one. If the types conflict ACE warns the user of the conflicts. Thanks to the flexibility of C++, ACE can merge options of type class if either the declared model are identical, or if one of the model is a direct descendent of the other. Paths ACE uses the JSONPath notation to represent paths. Triggers Models that are supposed to work in conjunction with plugin types can declare \"trigger\" patterns that will be used to load them depending on the option path in the instance. \"header\": { \"name\": \"ACME_EX\", \"author\": { \"name\": \"John Doe\", \"email\": \"jdoe@acme.com\" }, \"version\": \"1.0\", \"include\": [ \"plugin/base/model.json\", ... ], \"trigger\": [ \"$.*.acme\", ... ], \"doc\": \"ACME_EX configuration model\" } In the above example, the defined trigger allow that model to be loaded when the path match $.*.acme and the plugin use plugin/base/model.json as a base model. The path matched by the trigger is the full JSON path of the option instance.","title":"Models"},{"location":"models/#models","text":"","title":"Models"},{"location":"models/#top-level-structure","text":"Models are JSON objects that contain three entries: header , body and templates . The header entry contains information about the model, such as its author's name and e-mail, the its version string, and a line of documentation explaining the model's purpose. The body entry contains the definitions of the options expected by the model. The templates entry contains type definitions that can be injected into the model based on instance values. This injection is supported for options of type select . \"header\": { \"package\": [ \"my\", \"package\" ], \"author\": { \"name\": \"John Doe\", \"email\": \"jdoe@acme.com\" }, \"version\": \"1.0\", \"namespace\": [ \"my\", \"ns\" ], \"doc\": \"ACME configuration model\" } The package and namespace entries are related to C++ code generation. The package entry defines the compilation unit path of the configuration model. The compilation subsystem must provide an include path the can resolve the package path. The namespace entry defines the namespace to use for the generated classes.","title":"Top-level structure"},{"location":"models/#inheritance","text":"A model can extend external pre-existing models. When extending models, the options defined in these models are imported and merged in the newly defined models. Extended models can in turns extend models themselves. To extends from existing models, a model need to declare path and name of extended models in its headers using the include clause as follows: \"header\": { \"name\": \"ACME_EX\", \"author\": { \"name\": \"John Doe\", \"email\": \"jdoe@acme.com\" }, \"version\": \"1.0\", \"include\": [ \"a_path/a_model.json\", ... ], \"doc\": \"ACME_EX configuration model\" } Multiple extended models may be defining options that bear the same name. In that case, ACE checks if the option types are compatible by kind, arity, and dependencies. If the types are compatible, the options are merged into one. If the types conflict ACE warns the user of the conflicts. Thanks to the flexibility of C++, ACE can merge options of type class if either the declared model are identical, or if one of the model is a direct descendent of the other.","title":"Inheritance"},{"location":"models/#paths","text":"ACE uses the JSONPath notation to represent paths.","title":"Paths"},{"location":"models/#triggers","text":"Models that are supposed to work in conjunction with plugin types can declare \"trigger\" patterns that will be used to load them depending on the option path in the instance. \"header\": { \"name\": \"ACME_EX\", \"author\": { \"name\": \"John Doe\", \"email\": \"jdoe@acme.com\" }, \"version\": \"1.0\", \"include\": [ \"plugin/base/model.json\", ... ], \"trigger\": [ \"$.*.acme\", ... ], \"doc\": \"ACME_EX configuration model\" } In the above example, the defined trigger allow that model to be loaded when the path match $.*.acme and the plugin use plugin/base/model.json as a base model. The path matched by the trigger is the full JSON path of the option instance.","title":"Triggers"},{"location":"types/","text":"Types Types are JSON objects that define supported data types in configuration instances. A valid type require a bunch of attributes to be set. Five basic attributes are common to all types: Name Function kind the kind of type to define arity the arity of the option, one of ? , 1 , * , + , M:N doc a one-liner explaining the meaning of the option deprecated mark the option as deprecated default the default value to use if the option is omitted inherit if the option gets its value from the same option higher in the tree hook if the option value is based on another option's value kind , and doc are mandatory attribute. default , inherit , and hook may or may not be specified by the author. default takes a value of the same kind as the type. inherit is either true or false , being false by default. The arity and hook attributes are mutually exclusive. Arity ACE types can have either one of four kinds or arities, specified in the arity attribute: ? , meaning either one or no value (equivalent to optional); 1 , meaning one and only one value (equivalent to required); * , meaning any number of values (equivalent to 0:N); and + , meaning at least one value (equivalent to 1:N). M:N , with either bound optional. Marking a type as optional means that the type is not required by the application to operate properly. By extension, it means that no value at all for that type will be used by the application. Therefore, specifying a default field to an optional type is meaningless except if a dependency susceptible to promote the type to required exists in the model. Ranged and enumerated Ranged and enumerated types are types that support the range attribute and the either (enumeration) attribute. The range attribute The range attribute specifies a range within which the value must be defined: \"closed\": \"[ X, Y ]\", \"open\": \"( X, Y )\", \"open-left\": \"( X, Y ]\", \"open-right\": \"[ X, Y )\" The either attribute The either attribute specifies a list in which the value must be defined: \"either\": [ V0, V1, V2, V3 ] Value hook A hook is a string composed of three parts separated by : : \"SOURCE:MATCH:EXPANSION\" . SOURCE is the path of the option to be used as a value source. MATCH is a regular expression that define sub-pattern matches that will be later expanded into the EXPANSION field. The match/expansion syntax is similar to this of sed . Example: \"option1\": { \"kind\": \"string\", \"arity\": \"1\", \"doc\": \"an option\", \"default\": \"hello_world\" } // -> hello_world \"option2\": { \"kind\": \"string\", \"hook\": \"@.option1:([a-zA-Z]+)_([a-zA-Z]+):\\\\1, \\\\2 !\", \"doc\": \"a second option\" } // -> hello, world ! Kinds Type Range Enumeration Specifics boolean No Yes cpuid Yes Yes Match value with # of active cpus available on the system class No No enum No Yes file No Yes block, char, dir, fifo, regular float Yes Yes double ipv4 No Yes XXX.XXX.XXX.XXX, XXX as integer integer Yes Yes int64_t mac No Yes MAC address XX.XX.XX.XX.XX.XX, XX as hexadecimal plugin No No select No No string No Yes uri No Yes ipv4, file, http, ftp, smbcast Boolean The boolean kind of type describes a boolean type. Accepted values for that type are true and false . \"option\": { \"kind\": \"boolean\", \"arity\": \"1\", \"doc\": \"a boolean option\" } Integer The integer kind of type describes a 64-bit signed integer type. \"option\": { \"kind\": \"integer\", \"arity\": \"1\", \"doc\": \"an integer option\" } Float The float kind of type describes a 64-bit signed float type. \"option\": { \"kind\": \"float\", \"arity\": \"1\", \"doc\": \"a float option\" } It also support positive infinity +inf and negative infinity -inf values. CPUID The cpuid kind of type describes a CPU identifier type. When used, extra checks are performed to ensure that the CPUID refers to a valid CPU number. Supported values are any integer ranging from -1 (any CPU) to SYSTEM_MAX_CPU - 1 . Like integers, this option accept range , either , and default : \"option\": { \"kind\": \"cpuid\", \"arity\": \"1\", \"default\": -1, \"doc\": \"a CPUID option\", \"either\": [ -1, 0, 1 ] } File The file kind of type describes a filesystem file. When used, extra checks are performed to ensure that the file is corresponds to an allowed list of sub-types and can be accessed using specified mode. It requires one extra attribute: mode . The mode attribute is a string that contains the access mode to use. The accepted values are equivalent to these of fopen . \"option\": { \"kind\": \"file\", \"arity\": \"1\", \"doc\": \"a file option\", \"either\": [ \"fifo\", \"regular\" ], \"mode\": \"r+\" } The sub-types of file recognized are: block , character , directory , fifo , and regular . String The string kind of type describes a string type. It supports three extra attribute: either , length and match . The either attribute is a N-value array that defines the set of acceptable values for that type: \"option\": { \"kind\": \"string\", \"arity\": \"1\", \"doc\": \"a string option\", \"either\": [ \"hello\", \"world\" ] } The length attribute accepts a range that is used to enforce the length of the string value: \"option\": { \"kind\": \"string\", \"arity\": \"1\", \"doc\": \"a string option\", \"length\": \"[1, 10)\" } The match attributes accepts a regular expression that is used to enforce a specific format for the string: \"option\": { \"kind\": \"string\", \"arity\": \"1\", \"doc\": \"a string option\", \"match\": \"[a-z][0-9]+\" } MAC The mac kind of type describes a MAC address type. It supports one extra attribute: either . The either attribute is a N-value array that defines the set of acceptable values for that type: \"option\": { \"kind\": \"mac\", \"arity\": \"1\", \"doc\": \"a MAC option\", \"either\": [ \"00:11:22:33:44:55\", \"66:77:88:99:AA:BB\" ] } IPv4 The ipv4 kind of type describes a IPv4 address type. It supports one extra attribute: either . The either attribute is a N-value array that defines the set of acceptable values for that type: \"option\": { \"kind\": \"ipv4\", \"arity\": \"1\", \"doc\": \"an IPv4 option\", \"either\": [ \"192.168.1.1\", \"10.0.1.1\" ] URI The uri kind of type describes a URI type. When used, extra checks are performed to ensure that the URI is valid. Supported schemes are file and http . It supports one extra attribute: either . The either attribute is a N-value array that defines the set of acceptable schemes: \"option\": { \"kind\": \"uri\", \"arity\": \"1\", \"doc\": \"an URI option\", \"either\": [ \"file\" ] } Enum The enum kind of type describes an integer-based enumeration. It supports one extra attribute: bind . The bind attribute is a N-value map that defines the set of acceptable values: \"option\": { \"kind\": \"enum\", \"arity\": \"1\", \"bind\": { \"ENUM_VAL_A\": 0, \"ENUM_VAL_B\": 1, \"ENUM_VAL_C\": 2, \"ENUM_VAL_D\": 3 }, \"doc\": \"an enum option\" } The generated code looks like this: typedef enum _OptionType { ENUM_VAL_A = 0, ENUM_VAL_B = 1, ENUM_VAL_C = 2, ENUM_VAL_D = 3, } OptionType; Class The class kind of type describes an option in the model that is defined by an external model. Options of that type are usually implemented as sub-sections in the configuration instance. It requires one extra attribute: model . The model attribute is a string that contains the path and name of the model to use: \"option\": { \"kind\": \"class\", \"arity\": \"1\", \"doc\": \"a class option\", \"model\": \"my_path/my_model.json\" } Select The select kind of type describes a selector of options that are dynamically generated using values from the configuration instance. The values of that option are used as name for options which types are taken from the templates section of the model. It requires two extra attributes: template and size . The template attribute is a string that contains the name of the template to use for the option. The size attribute is an arity attribute that defines how many entries in the selector are expected: \"strings\": { \"kind\": \"select\", \"arity\": \"?\", \"size\": \"+\", \"doc\": \"a select option\", \"template\": \"my_string_template\" } The example above would dynamically generate options with type my_string_template and names defined as values in the select option. See the instance example below: \"strings\": { \"A_string\": \"hello\", \"B_string\": \"world\" } It supports one extra attribute: either . The either attribute is a N-value array that defines the valid values for that type. \"strings\": { \"kind\": \"select\", \"arity\": \"?\", \"doc\": \"a select option\", \"either\": [ \"foo\", \"bar\" ], \"template\": \"my_string_template\" } The example above defines a select option that generate new options of type my_string_template and that allow only the values hello and world : \"strings\": { \"foo\": \"hello\", \"bar\": \"world\" } Plugin The plugin kind type describes an selector objects that are dynamically generated using values from the configuration instance. These objects must inherit from the same base model. Plugins are dynamically loaded at run time and options are automatically computed using the trigger element of the model header, and the option are made available if and only if the models in the mapping are found in the model path. It requires two extra attributes: model , and target-arity . The model attribute is a string that contains the path and name of the model to use as a base model for the plugins. By default, the expected arity of the target class is 1 . The attribute target-arity can be used to alter that default arity to + : \"plugins\": { \"kind\": \"plugin\", \"arity\": \"?\", \"doc\": \"a plugin option\", \"model\": \"my/base/Model.json\", \"target-arity\": \"+\" } The new arity will be applied to all elements of the plugin.","title":"Types"},{"location":"types/#types","text":"Types are JSON objects that define supported data types in configuration instances. A valid type require a bunch of attributes to be set. Five basic attributes are common to all types: Name Function kind the kind of type to define arity the arity of the option, one of ? , 1 , * , + , M:N doc a one-liner explaining the meaning of the option deprecated mark the option as deprecated default the default value to use if the option is omitted inherit if the option gets its value from the same option higher in the tree hook if the option value is based on another option's value kind , and doc are mandatory attribute. default , inherit , and hook may or may not be specified by the author. default takes a value of the same kind as the type. inherit is either true or false , being false by default. The arity and hook attributes are mutually exclusive.","title":"Types"},{"location":"types/#arity","text":"ACE types can have either one of four kinds or arities, specified in the arity attribute: ? , meaning either one or no value (equivalent to optional); 1 , meaning one and only one value (equivalent to required); * , meaning any number of values (equivalent to 0:N); and + , meaning at least one value (equivalent to 1:N). M:N , with either bound optional. Marking a type as optional means that the type is not required by the application to operate properly. By extension, it means that no value at all for that type will be used by the application. Therefore, specifying a default field to an optional type is meaningless except if a dependency susceptible to promote the type to required exists in the model.","title":"Arity"},{"location":"types/#ranged-and-enumerated","text":"Ranged and enumerated types are types that support the range attribute and the either (enumeration) attribute.","title":"Ranged and enumerated"},{"location":"types/#the-range-attribute","text":"The range attribute specifies a range within which the value must be defined: \"closed\": \"[ X, Y ]\", \"open\": \"( X, Y )\", \"open-left\": \"( X, Y ]\", \"open-right\": \"[ X, Y )\"","title":"The range attribute"},{"location":"types/#the-either-attribute","text":"The either attribute specifies a list in which the value must be defined: \"either\": [ V0, V1, V2, V3 ]","title":"The either attribute"},{"location":"types/#value-hook","text":"A hook is a string composed of three parts separated by : : \"SOURCE:MATCH:EXPANSION\" . SOURCE is the path of the option to be used as a value source. MATCH is a regular expression that define sub-pattern matches that will be later expanded into the EXPANSION field. The match/expansion syntax is similar to this of sed . Example: \"option1\": { \"kind\": \"string\", \"arity\": \"1\", \"doc\": \"an option\", \"default\": \"hello_world\" } // -> hello_world \"option2\": { \"kind\": \"string\", \"hook\": \"@.option1:([a-zA-Z]+)_([a-zA-Z]+):\\\\1, \\\\2 !\", \"doc\": \"a second option\" } // -> hello, world !","title":"Value hook"},{"location":"types/#kinds","text":"Type Range Enumeration Specifics boolean No Yes cpuid Yes Yes Match value with # of active cpus available on the system class No No enum No Yes file No Yes block, char, dir, fifo, regular float Yes Yes double ipv4 No Yes XXX.XXX.XXX.XXX, XXX as integer integer Yes Yes int64_t mac No Yes MAC address XX.XX.XX.XX.XX.XX, XX as hexadecimal plugin No No select No No string No Yes uri No Yes ipv4, file, http, ftp, smbcast","title":"Kinds"},{"location":"types/#boolean","text":"The boolean kind of type describes a boolean type. Accepted values for that type are true and false . \"option\": { \"kind\": \"boolean\", \"arity\": \"1\", \"doc\": \"a boolean option\" }","title":"Boolean"},{"location":"types/#integer","text":"The integer kind of type describes a 64-bit signed integer type. \"option\": { \"kind\": \"integer\", \"arity\": \"1\", \"doc\": \"an integer option\" }","title":"Integer"},{"location":"types/#float","text":"The float kind of type describes a 64-bit signed float type. \"option\": { \"kind\": \"float\", \"arity\": \"1\", \"doc\": \"a float option\" } It also support positive infinity +inf and negative infinity -inf values.","title":"Float"},{"location":"types/#cpuid","text":"The cpuid kind of type describes a CPU identifier type. When used, extra checks are performed to ensure that the CPUID refers to a valid CPU number. Supported values are any integer ranging from -1 (any CPU) to SYSTEM_MAX_CPU - 1 . Like integers, this option accept range , either , and default : \"option\": { \"kind\": \"cpuid\", \"arity\": \"1\", \"default\": -1, \"doc\": \"a CPUID option\", \"either\": [ -1, 0, 1 ] }","title":"CPUID"},{"location":"types/#file","text":"The file kind of type describes a filesystem file. When used, extra checks are performed to ensure that the file is corresponds to an allowed list of sub-types and can be accessed using specified mode. It requires one extra attribute: mode . The mode attribute is a string that contains the access mode to use. The accepted values are equivalent to these of fopen . \"option\": { \"kind\": \"file\", \"arity\": \"1\", \"doc\": \"a file option\", \"either\": [ \"fifo\", \"regular\" ], \"mode\": \"r+\" } The sub-types of file recognized are: block , character , directory , fifo , and regular .","title":"File"},{"location":"types/#string","text":"The string kind of type describes a string type. It supports three extra attribute: either , length and match . The either attribute is a N-value array that defines the set of acceptable values for that type: \"option\": { \"kind\": \"string\", \"arity\": \"1\", \"doc\": \"a string option\", \"either\": [ \"hello\", \"world\" ] } The length attribute accepts a range that is used to enforce the length of the string value: \"option\": { \"kind\": \"string\", \"arity\": \"1\", \"doc\": \"a string option\", \"length\": \"[1, 10)\" } The match attributes accepts a regular expression that is used to enforce a specific format for the string: \"option\": { \"kind\": \"string\", \"arity\": \"1\", \"doc\": \"a string option\", \"match\": \"[a-z][0-9]+\" }","title":"String"},{"location":"types/#mac","text":"The mac kind of type describes a MAC address type. It supports one extra attribute: either . The either attribute is a N-value array that defines the set of acceptable values for that type: \"option\": { \"kind\": \"mac\", \"arity\": \"1\", \"doc\": \"a MAC option\", \"either\": [ \"00:11:22:33:44:55\", \"66:77:88:99:AA:BB\" ] }","title":"MAC"},{"location":"types/#ipv4","text":"The ipv4 kind of type describes a IPv4 address type. It supports one extra attribute: either . The either attribute is a N-value array that defines the set of acceptable values for that type: \"option\": { \"kind\": \"ipv4\", \"arity\": \"1\", \"doc\": \"an IPv4 option\", \"either\": [ \"192.168.1.1\", \"10.0.1.1\" ]","title":"IPv4"},{"location":"types/#uri","text":"The uri kind of type describes a URI type. When used, extra checks are performed to ensure that the URI is valid. Supported schemes are file and http . It supports one extra attribute: either . The either attribute is a N-value array that defines the set of acceptable schemes: \"option\": { \"kind\": \"uri\", \"arity\": \"1\", \"doc\": \"an URI option\", \"either\": [ \"file\" ] }","title":"URI"},{"location":"types/#enum","text":"The enum kind of type describes an integer-based enumeration. It supports one extra attribute: bind . The bind attribute is a N-value map that defines the set of acceptable values: \"option\": { \"kind\": \"enum\", \"arity\": \"1\", \"bind\": { \"ENUM_VAL_A\": 0, \"ENUM_VAL_B\": 1, \"ENUM_VAL_C\": 2, \"ENUM_VAL_D\": 3 }, \"doc\": \"an enum option\" } The generated code looks like this: typedef enum _OptionType { ENUM_VAL_A = 0, ENUM_VAL_B = 1, ENUM_VAL_C = 2, ENUM_VAL_D = 3, } OptionType;","title":"Enum"},{"location":"types/#class","text":"The class kind of type describes an option in the model that is defined by an external model. Options of that type are usually implemented as sub-sections in the configuration instance. It requires one extra attribute: model . The model attribute is a string that contains the path and name of the model to use: \"option\": { \"kind\": \"class\", \"arity\": \"1\", \"doc\": \"a class option\", \"model\": \"my_path/my_model.json\" }","title":"Class"},{"location":"types/#select","text":"The select kind of type describes a selector of options that are dynamically generated using values from the configuration instance. The values of that option are used as name for options which types are taken from the templates section of the model. It requires two extra attributes: template and size . The template attribute is a string that contains the name of the template to use for the option. The size attribute is an arity attribute that defines how many entries in the selector are expected: \"strings\": { \"kind\": \"select\", \"arity\": \"?\", \"size\": \"+\", \"doc\": \"a select option\", \"template\": \"my_string_template\" } The example above would dynamically generate options with type my_string_template and names defined as values in the select option. See the instance example below: \"strings\": { \"A_string\": \"hello\", \"B_string\": \"world\" } It supports one extra attribute: either . The either attribute is a N-value array that defines the valid values for that type. \"strings\": { \"kind\": \"select\", \"arity\": \"?\", \"doc\": \"a select option\", \"either\": [ \"foo\", \"bar\" ], \"template\": \"my_string_template\" } The example above defines a select option that generate new options of type my_string_template and that allow only the values hello and world : \"strings\": { \"foo\": \"hello\", \"bar\": \"world\" }","title":"Select"},{"location":"types/#plugin","text":"The plugin kind type describes an selector objects that are dynamically generated using values from the configuration instance. These objects must inherit from the same base model. Plugins are dynamically loaded at run time and options are automatically computed using the trigger element of the model header, and the option are made available if and only if the models in the mapping are found in the model path. It requires two extra attributes: model , and target-arity . The model attribute is a string that contains the path and name of the model to use as a base model for the plugins. By default, the expected arity of the target class is 1 . The attribute target-arity can be used to alter that default arity to + : \"plugins\": { \"kind\": \"plugin\", \"arity\": \"?\", \"doc\": \"a plugin option\", \"model\": \"my/base/Model.json\", \"target-arity\": \"+\" } The new arity will be applied to all elements of the plugin.","title":"Plugin"}]}